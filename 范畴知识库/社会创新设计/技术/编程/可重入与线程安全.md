网上找通常找得《可重入与线程安全的关系》之类的文章，总结下来*“可重入一定线程安全，线程安全不一定可重入之类”*的结论。总之，可重入与线程安全有关系，但两者在安全性问题上的考虑是不一样的。得先从**单线程的可重入性**说起。

## 单线程不可重入与信号安全
一个函数在没有执行完毕之前，又把自己执行了一边，这样的行为看起来就像**重新进入**这个函数一样。通常这样的情况很容易在**递归代码**中找到。还有地方能遇到那就是**中断**。

在信号处理程序中，不能判断捕捉到信号时，进程在何处执行。假如进程之前正好在处理一个`malloc`动作，还没有处理完毕，跳转至信号处理函数中，而其中又调用了`malloc`函数，这个时候，极有可能会对进程造成破坏。因为`malloc`通常为它所分配的区域维护一个链接表，而上面运行信号处理函数时，进程极有可能正在更改这个链接表，而信号处理函数再次的调用就会在处理链接表时失败。

上面这种情况导致了不安全情况发生，问题出在`malloc`函数上，我们称`malloc`函数是**不可重入**的，因为重入它会不安全。

前人经验总结下来，满足下列条件的函数**多数**是不可重入的：` 
1) 函数体内使用了静态的数据结构；
2) 函数体内调用了malloc()或者free()函数；
3) 函数体内调用了标准I/O函数。`

上面`malloc`的单线程不可重入问题，引发的原因是处理`malloc`时被中断打断，打断后又打算重入`malloc`而造成的错误。解决办法是在调用`malloc`前，屏蔽掉某些信号，保证`malloc`不会被打断。

那如果有一些函数，能保证函数被信号处理函数**安全重入**的，就称它为（异步）信号安全函数。

## 线程安全
继续考虑`malloc`，`malloc`是线程安全的，因为`malloc`对链接表进行操作时会加锁，这样另外线程访问链接表时，线程会被互斥锁阻塞，直到`malloc`释放锁。如果`malloc`对链接表进行操作时不加锁，那么A线程在`malloc`修改链接表时突然执行另一个线程B，也执行了`malloc`，那么不安全的问题也会出现。

## 线程安全却不可重入
考虑`malloc`。又或者一个函数，内部通过互斥锁保护共享数据区，但是它不能递归调用自己，这样的重入方式会造成线程的死锁。

## 总结
一个函数可以被多个线程正确调用不会出错，则称其为**线程安全**。
一个函数在被信号打断且可以在信号内重入的，则称其为**信号安全**。
一个函数是否可重入，既要考虑**线程安全**，也要考虑**信号安全**。否则，严格意义上，函数都不可以称之为**可重入函数**


