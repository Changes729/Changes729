文章来源：[阿里云云栖号](https://mp.weixin.qq.com/s/RsC1GIFwrEAs90u9deN0rA)

> **_[汉语词典]_**
>
> _私域_: 即品牌自运营的空间，可以帮助品牌持续运营自己的消费者。

**00**

> 淘宝也在快速调整私域的布局：**淘宝也有非常多的私域产品，譬如店铺、客服、消息等**。在这些场景中，品牌商家需要**利用创意、内容和服务留住消费者群体，并产生销售转化。**但是做私域并不仅仅只是纯销售，更要用内容和服务把人留下来，让场里的人越留越多，这部分常驻人群才是「私域流量」。

![图片](/api/file/image/ln/640)

**01**

什么是小部件？淘宝耐克有个例子

![img](/api/file/image/ln/640-16272793246492)

**02**

小部件技术实现

![图片](/api/file/image/ln/640-16272794942404)

面向与研发强相关的小部件， 我们希望开发者在**同一个 IDE 中可以完成小部件/小程序的研发、调试、预览、上传等功能**，所以「淘宝开发者工具」作为编辑工具与研发服务的结合平台，提高工具、服务之间的串联效率，一站式地帮助小部件的开发者提升整体效率。此外，**在游戏互动卡片这块，开发者也可以直接使用游戏引擎的 IDE 来提高自身的研发效率**。

开发者可以基于「淘宝开发者工具」的生产环境来构建自己的小部件，小部件的整个生产流程也是对齐小程序的开发模式，小部件积极拥抱三方开放生态，开发者可以使用标准的小程序 DSL，小部件的上层技术生态对齐小程序 Web 生态，无缝支持小程序前端框架、游戏引擎的运行接入。

此外**面对表单配置能力，我们还在「淘宝开发者工具」支持了 JsonSchema 能力，通过 JsonSchema 的开放，小部件的开发者可以完成与小部件配套的商家端表单配置能力的研发，配置表单帮助商家可以灵活控制小部件的前台属性和后台接口。**

开发者入驻后，**选择自身需要研发投放的场景后，可以获取不同场景的尺寸信息和视觉规范，通过这层约束得以保证场景的消费者体验一致性**。而对此，小部件的开发者通过我们的适配方案后仅需简单适配即可完成产物交付，实现一套代码多处运行的技术目标。

为此，我们提供了一套完整的投放能力。**当开发者完成小部件的交付并且审核通过后，商家需要在商家端完成小部件的业务配置**，并投放到线上环境。商家可以自主选择投放的场景，譬如店铺、会员、订阅、直播等等。

卡片本身的特殊性导致了对**渲染、性能、体验**的要求极高。小部件容器提供了高效、稳定的环境来保证业务代码的执行效率。

能力方面，通过基础库技术协议的对齐，**所有的基础/业务 API 能力我们都保证了对小程序容器的复用**，并且和支付宝小程序容器保证了接口标准的一致性。这意味着开发者可以几乎 0 成本地调用所有小程序开放出来的 API 能力并获得和小程序完全一致的体验。

渲染方面，**传统的 WebView 渲染方案在卡片形态下会比较厚重**，多个卡片共存同一场景下的内存和体验问题也无法得到很好解决。为此，我们重新设计了一套更适合卡片场景的渲染方案，相对于小程序的 WebView 渲染引擎，**我们在卡片场景中替换为全新的渲染引擎，即 Weex2.0。**

**通过 Weex2.0 的跨平台渲染能力，我们在 iOS 和 Android 上保持了极高的一致性**。三方场景的特殊性会导致卡片本身的技术容错率很低，所以，**从性能和复杂度角度出发的角度考虑，我们也收敛了整体 CSS 样式的支持度**。整体样式能力的规范的整体设计很大程度上兼容 W3C 标准，实现了一部分子集，在子集范围内的功能都和标准一致。

此外，**小部件的运行安全也是非常重要的，为此我们引入了沙箱机制**。通过沙箱机制我们得以保证不同的小部件环境之间是互相隔离并不互相影响的，通过底层技术的复用，我们也合并了多个 JavaScript 虚拟机的创建，保证性能和效率能够最大化。

![图片](/api/file/image/ln/640-16272798780296)

**脚本引擎**

小部件的技术产物是 JavaScript 源文件，小部件中我们使用了 QuickJS 虚拟机作为脚本执行引擎。**基于 QuickJS，我们可以获取一个轻量并且高效的 JavaScript 执行环境。**相较于庞大的 V8 引擎，**QuickJS 虚拟机的启动性能和包大小收益都远远超出我们的预期**。

在虚拟机层面的优化工作有助于我们使用新的技术特性来加速，基于「ByteCode」机制，我们已经**考虑在小部件构建的时候把 JavaScript 源码预编译为二进制来加速整体的渲染**。此外，我们也在推进标准字节码的设计工作，通过字节码的优化，可以获取加载速度与代码体积的双重优化。

**渲染引擎**

渲染引擎是小部件的核心， 我们使用了淘宝自研的渲染引擎「Weex2.0」，Weex2.0 的前身是 Weex1.0，相对于1.0 的 系统 UI 渲染，2.0 上我们全面切换到了跨平台 C++ 自绘方案。**通过 C++ 的跨平台开发，我们在原生层面使用 C++ 实现了组件化、MVVM、声明式模板、响应式更新等复杂功能，也顺便抹平了 iOS 和 Android 上平台相关的组件差异。**

接口注册层面，我们**通过 JS Binding 直接把原生渲染接口注册绑定到 JavaScript 环境中，几乎没有序列化成本**。C++ 框架下沉以后，可以更加细粒度的实现节点更新和回收复用。

渲染管线上，我们**借鉴了 Flutter Engine 的线程模型及布局算法，最后会被提交到 Skia 本身的渲染流程上**。这部分工作的复用有助于我们快速实现落地，此外由于我们的渲染管线是面向 Web 的技术特点设计，没有 Flutter FrameWork 中的 Dart Widget 概念，更加贴合前端的技术栈。

